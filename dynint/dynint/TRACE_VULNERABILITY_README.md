# Spacecraft Server Vulnerability Path Tracer

Complete dynamic tracing solution to capture the full execution path from `recvfrom` network packet reception to the CWE-20 input validation vulnerability in the spacecraft server.

## Overview

This toolkit provides **dynamic runtime tracing** (not static analysis) to capture every machine instruction executed along the vulnerability path. Unlike `objdump` which shows static disassembly, this captures **actual runtime execution** including:

- System calls (recvfrom@plt)
- All intermediate callsites
- Function arguments and return values
- Register and memory operations
- Timing information

## Components

### 1. `trace_vulnerability_path.py`
Main orchestration script that:
- Generates static analysis map with `dynmap`
- Runs dynamic trace with `dyntrace` (Frida backend)
- Captures all 31 critical callsites in the vulnerability path
- Analyzes and reports results

### 2. `send_test_packet.py`
Packet generator that sends CCSDS/PUS formatted packets to trigger the vulnerability:
- Creates properly formatted CCSDS packets (6-byte header)
- Adds PUS telecommand header with service_type byte
- Supports multiple exploit scenarios (service_type = 0x00, 0xFF, 0x80, etc.)
- Can send continuous packets for extended tracing

### 3. `run_full_trace.sh`
Bash orchestration script that:
- Starts server under dynamic instrumentation
- Sends test packets at appropriate times
- Captures complete trace
- Generates analysis report

## Quick Start

### Using Docker (Recommended)

```bash
# 1. Build Docker containers
cd /home/user/algebra-system/dynint/dynint
docker compose build

# 2. Run complete trace (automated)
docker compose run --rm dynint-frida bash run_full_trace.sh

# 3. View results
docker compose run --rm dynint-frida cat output/vulnerability_report.txt
```

### Direct Usage (Without Docker)

```bash
# 1. Make scripts executable
chmod +x trace_vulnerability_path.py send_test_packet.py run_full_trace.sh

# 2. Run automated trace
./run_full_trace.sh

# 3. View results
cat output/vulnerability_report.txt
```

## Advanced Usage

### Manual Step-by-Step Execution

```bash
# Step 1: Generate static map
python -m dynint.cli map ./spacecraft_server_linux_x86 \
    --output output/map.json \
    --with-dwarf \
    --bytes

# Step 2: Start trace in background (15 second duration)
python trace_vulnerability_path.py \
    --binary ./spacecraft_server_linux_x86 \
    --duration 15 &

TRACE_PID=$!

# Step 3: Wait for server to start
sleep 3

# Step 4: Send exploit packets
python send_test_packet.py --scenarios

# Step 5: Wait for trace to complete
wait $TRACE_PID

# Step 6: View results
cat output/vulnerability_report.txt
```

### Custom Packet Testing

```bash
# Send single packet with custom service_type
python send_test_packet.py \
    --host 127.0.0.1 \
    --port 5555 \
    --service-type 0xFF \
    --service-subtype 0x01 \
    --payload deadbeef

# Send multiple scenarios
python send_test_packet.py --scenarios

# Continuous sending (useful for extended traces)
python send_test_packet.py \
    --continuous \
    --interval 2.0 \
    --service-type 0x80
```

### Trace Specific Addresses

```bash
# Trace only critical addresses
python -m dynint.cli trace \
    --spawn ./spacecraft_server_linux_x86 \
    --map output/map.json \
    --callsite 0x35f5 \
    --callsite 0x3285 \
    --callsite 0x2e40 \
    --fn recvfrom \
    --output output/custom_trace.jsonl \
    --duration 10
```

## Traced Addresses

The system traces 31 critical addresses organized in 10 groups:

### Group 1: RECVFROM_SETUP (1 instruction)
- **0x35f5**: `call recvfrom@plt` - Network packet entry point

### Group 2: RECVFROM_RESULT (3 instructions)
- **0x35fa**: `mov [rbp-0x848],rax` - Store bytes received
- **0x3601**: `cmp [rbp-0x848],0x0` - Check if data received
- **0x3609**: `jns 363b` - Branch if data valid

### Group 3: PACKET_LOGGING (5 instructions)
- **0x37c9**: `mov eax,[rbp-0x84c]` - Loop counter
- **0x37d1**: `movzx eax,BYTE PTR[...]` - Read buffer byte
- **0x37d9**: `movzx eax,al` - Zero-extend
- **0x37dc**: `mov esi,eax` - Setup printf argument
- **0x37ed**: `call printf@plt` - Log packet

### Group 4: PARSECCSDS_SETUP (6 instructions)
- **0x384c**: `mov rdx,[rbp-0x848]` - Load packet length
- **0x3853**: `lea rcx,[rbp-0x820]` - Calculate buffer address
- **0x385a**: `mov rax,[rbp-0x868]` - Load 'this' pointer
- **0x3861**: `mov rsi,rcx` - Set buffer parameter
- **0x3864**: `mov rdi,rax` - Set 'this' parameter
- **0x3867**: `call ParseCCSDSPacket` - Parse packet

### Group 5: PUS_HEADER_CALC (3 instructions)
- **0x326f**: `add rax,0x6` - Skip 6-byte CCSDS header
- **0x3273**: `mov [rbp-0x50],rax` - Store PUS header address
- **0x3277**: `mov rax,[rbp-0x50]` - Reload PUS header address

### Group 6: PUS_VERSION (3 instructions)
- **0x327b**: `movzx eax,BYTE PTR[rax]` - Read PUS version byte
- **0x327e**: `mov [rbp-0x69],al` - Store PUS version
- **0x3281**: `mov rax,[rbp-0x50]` - Reload PUS header address

### Group 7: SERVICE_TYPE_READ (2 instructions) ðŸš¨ CRITICAL
- **0x3285**: `movzx eax,BYTE PTR[rax+0x1]` - **READ service_type from network packet**
- **0x3289**: `mov [rbp-0x68],al` - **Store service_type for processing**

### Group 8: PROCESSPUS_SETUP (4 instructions)
- **0x3505**: `movzx edx,[rbp-0x67]` - Load service_subtype
- **0x3509**: `movzx esi,[rbp-0x68]` - **Load service_type from network**
- **0x3515**: `mov r8d,edi` - Set destination_id
- **0x351b**: `call ProcessPUSCommand` - Process command

### Group 9: PROCESSPUS_PARAMS (2 instructions)
- **0x2d1b**: `mov ecx,esi` - Move service_type to working register
- **0x2d1d**: `mov [rbp-0xc],cl` - Store service_type for validation

### Group 10: CWE20_VULNERABILITY (2 instructions) ðŸš¨ CRITICAL
- **0x2e40**: `cmp [rbp-0xc],0x0` - **CWE-20: Insufficient validation (only checks == 0)**
- **0x2e44**: `jne 2eb2` - **EXPLOIT: Malicious values (0xFF, 0x80) bypass validation**

## Data Flow

The critical byte flows through memory as follows:

```
Network UDP Packet (service_type byte at offset 7)
    â†“
recvfrom@plt â†’ buffer[rbp-0x820]
    â†“
buffer[7] â†’ service_type byte = 0xFF (malicious)
    â†“
0x3285: Read from buffer[6+1] â†’ EAX register
    â†“
0x3289: Store EAX â†’ [rbp-0x68] (local variable)
    â†“
0x3509: Load [rbp-0x68] â†’ ESI register (function parameter)
    â†“
0x2d1b: Move ESI â†’ ECX
    â†“
0x2d1d: Store CL â†’ [rbp-0xc] (validation variable)
    â†“
0x2e40: Compare [rbp-0xc] with 0
    â†“
VULNERABILITY: Only checks if service_type == 0
    â†“
0xFF â‰  0 â†’ Validation BYPASSED â†’ Command processed!
```

## Output Files

### `output/vulnerability_map.json`
Static analysis map containing:
- All functions and basic blocks
- PLT callsites with addresses
- DWARF debug information
- Instruction bytes

### `output/vulnerability_trace.jsonl`
JSONL format trace with entries like:
```json
{
  "kind": "callsite",
  "static": "0x3285",
  "runtime": "0x5555557c3285",
  "target": "movzx",
  "tid": 12345,
  "ts": 1699564123.456
}
```

### `output/vulnerability_report.txt`
Human-readable report showing:
- Execution path grouped by stage
- All traced instructions
- Function call details
- Vulnerability confirmation
- Statistics

## Docker Environment

### Build
```bash
docker compose build
```

### Run Full Trace
```bash
docker compose run --rm dynint-frida bash run_full_trace.sh
```

### Interactive Shell
```bash
docker compose run --rm dynint-frida bash
```

### Custom Commands
```bash
# Generate map only
docker compose run --rm dynint-frida \
    python -m dynint.cli map ./spacecraft_server_linux_x86 \
    -o output/map.json

# Send test packet
docker compose run --rm dynint-frida \
    python send_test_packet.py --scenarios
```

## Troubleshooting

### No events captured
- Ensure server started successfully
- Check that packets are being sent (use `--scenarios` flag)
- Increase trace duration (`--duration 30`)
- Check trace log: `cat /tmp/trace_log.txt`

### Server not listening
- Server might need more time to start (increase sleep duration)
- Check correct port (default 5555)
- Verify binary is executable

### Frida errors
- Run in Docker (pre-configured environment)
- Ensure Frida is properly installed: `pip install frida-tools`
- Check permissions

## Key Differences from Static Analysis

| Static (objdump) | Dynamic (this tool) |
|-----------------|---------------------|
| Shows all possible code | Shows only executed code |
| No runtime values | Captures actual arguments/returns |
| Can't trace into PLT | Traces through system calls |
| No timing info | Precise timestamps |
| Manual analysis | Automated path detection |

## CWE-20 Vulnerability Details

**Vulnerability Type**: Improper Input Validation (CWE-20)

**Location**: `ProcessPUSCommand` at address 0x2e40

**Issue**: The service_type byte from network packets is only validated to check if it equals 0:
```asm
cmp BYTE PTR [rbp-0xc],0x0  ; Only checks if service_type == 0
jne 2eb2                     ; If != 0, continue processing
```

**Impact**: Values like 0xFF (255) or 0x80 (128) bypass validation and are processed as valid commands, potentially causing:
- Out-of-bounds array access
- Undefined behavior
- Command injection
- System compromise

**Fix**: Add upper bound validation:
```c
if (service_type == 0 || service_type > MAX_SERVICE_TYPE) {
    return ERROR_INVALID_SERVICE_TYPE;
}
```

## License

Part of the dynint toolkit for binary analysis and dynamic tracing.

## References

- CCSDS Packet Telemetry Standard: CCSDS 102.0-B-5
- PUS Telecommand Standard: ECSS-E-ST-70-41C
- CWE-20: Improper Input Validation: https://cwe.mitre.org/data/definitions/20.html
- Frida Dynamic Instrumentation: https://frida.re/
