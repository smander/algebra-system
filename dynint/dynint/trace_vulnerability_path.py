#!/usr/bin/env python3
"""
Comprehensive script to trace the execution path from recvfrom to CWE-20 vulnerability.

This script:
1. Uses dynint's dyntrace to capture runtime execution
2. Traces specific callsites along the vulnerability path
3. Tracks the service_type byte through memory
4. Outputs detailed execution trace with instruction-level granularity

Key addresses to trace:
- 0x35f5: recvfrom call (entry point)
- 0x35fa-0x3609: recvfrom result handling
- 0x37c9-0x37ed: packet logging
- 0x384c-0x3867: ParseCCSDSPacket setup and call
- 0x326f-0x3289: service_type extraction from packet
- 0x3505-0x351b: ProcessPUSCommand setup and call
- 0x2d1b-0x2d1d: service_type parameter handling
- 0x2e40-0x2e44: CWE-20 vulnerability point
"""

import argparse
import json
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional

# All critical addresses in the vulnerability path
VULNERABILITY_PATH_ADDRESSES = {
    # Group 1: RECVFROM_SETUP
    0x35f5: {"group": "RECVFROM_SETUP", "desc": "call recvfrom@plt"},

    # Group 2: RECVFROM_RESULT
    0x35fa: {"group": "RECVFROM_RESULT", "desc": "mov [rbp-0x848],rax - store bytes received"},
    0x3601: {"group": "RECVFROM_RESULT", "desc": "cmp [rbp-0x848],0x0 - check data received"},
    0x3609: {"group": "RECVFROM_RESULT", "desc": "jns 363b - branch if data received"},

    # Group 3: PACKET_LOGGING
    0x37c9: {"group": "PACKET_LOGGING", "desc": "mov eax,[rbp-0x84c] - loop counter"},
    0x37d1: {"group": "PACKET_LOGGING", "desc": "movzx eax,BYTE PTR[...] - read buffer byte"},
    0x37d9: {"group": "PACKET_LOGGING", "desc": "movzx eax,al - zero-extend"},
    0x37dc: {"group": "PACKET_LOGGING", "desc": "mov esi,eax - setup printf arg"},
    0x37ed: {"group": "PACKET_LOGGING", "desc": "call printf@plt"},

    # Group 4: PARSECCSDS_SETUP
    0x384c: {"group": "PARSECCSDS_SETUP", "desc": "mov rdx,[rbp-0x848] - load length"},
    0x3853: {"group": "PARSECCSDS_SETUP", "desc": "lea rcx,[rbp-0x820] - buffer address"},
    0x385a: {"group": "PARSECCSDS_SETUP", "desc": "mov rax,[rbp-0x868] - this pointer"},
    0x3861: {"group": "PARSECCSDS_SETUP", "desc": "mov rsi,rcx - set buffer param"},
    0x3864: {"group": "PARSECCSDS_SETUP", "desc": "mov rdi,rax - set this param"},
    0x3867: {"group": "PARSECCSDS_SETUP", "desc": "call ParseCCSDSPacket"},

    # Group 5: PUS_HEADER_CALC
    0x326f: {"group": "PUS_HEADER_CALC", "desc": "add rax,0x6 - skip CCSDS header"},
    0x3273: {"group": "PUS_HEADER_CALC", "desc": "mov [rbp-0x50],rax - store PUS header addr"},
    0x3277: {"group": "PUS_HEADER_CALC", "desc": "mov rax,[rbp-0x50] - reload PUS header addr"},

    # Group 6: PUS_VERSION
    0x327b: {"group": "PUS_VERSION", "desc": "movzx eax,BYTE PTR[rax] - read PUS version"},
    0x327e: {"group": "PUS_VERSION", "desc": "mov [rbp-0x69],al - store PUS version"},
    0x3281: {"group": "PUS_VERSION", "desc": "mov rax,[rbp-0x50] - reload PUS header addr"},

    # Group 7: SERVICE_TYPE_READ (CRITICAL)
    0x3285: {"group": "SERVICE_TYPE_READ", "desc": "üö® movzx eax,BYTE PTR[rax+0x1] - READ service_type from network"},
    0x3289: {"group": "SERVICE_TYPE_READ", "desc": "üö® mov [rbp-0x68],al - store service_type"},

    # Group 8: PROCESSPUS_SETUP
    0x3505: {"group": "PROCESSPUS_SETUP", "desc": "movzx edx,[rbp-0x67] - load service_subtype"},
    0x3509: {"group": "PROCESSPUS_SETUP", "desc": "üö® movzx esi,[rbp-0x68] - load service_type from network"},
    0x3515: {"group": "PROCESSPUS_SETUP", "desc": "mov r8d,edi - set destination_id"},
    0x351b: {"group": "PROCESSPUS_SETUP", "desc": "call ProcessPUSCommand"},

    # Group 9: PROCESSPUS_PARAMS
    0x2d1b: {"group": "PROCESSPUS_PARAMS", "desc": "mov ecx,esi - move service_type to working reg"},
    0x2d1d: {"group": "PROCESSPUS_PARAMS", "desc": "mov [rbp-0xc],cl - store service_type for validation"},

    # Group 10: CWE20_VULNERABILITY (CRITICAL)
    0x2e40: {"group": "CWE20_VULNERABILITY", "desc": "üö® cmp [rbp-0xc],0x0 - CWE-20: Compare service_type with 0"},
    0x2e44: {"group": "CWE20_VULNERABILITY", "desc": "üö® jne 2eb2 - EXPLOITED: malicious command processed"},
}

# Function names to trace
FUNCTIONS_TO_TRACE = [
    "recvfrom",
    "ParseCCSDSPacket",
    "_ZN19SpacecraftUDPServer16ParseCCSDSPacketEPKhm",  # Mangled name
    "ProcessPUSCommand",
    "_ZN19SpacecraftUDPServer17ProcessPUSCommandEhhRKSt6vectorIhSaIhEEt",  # Mangled name
]


def run_map_generation(binary_path: Path, output_path: Path) -> bool:
    """Generate the static map with all necessary information."""
    print("[1/4] Generating static analysis map...")

    cmd = [
        "python", "-m", "dynint.cli", "map",
        str(binary_path),
        "--output", str(output_path),
        "--with-dwarf",
        "--bytes",
        "--analysis-level", "basic-blocks"
    ]

    print(f"  Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"  ‚ùå Map generation failed!")
        print(f"  stderr: {result.stderr}")
        return False

    print(f"  ‚úÖ Map generated: {output_path}")
    return True


def run_trace(
    binary_path: Path,
    map_path: Path,
    output_path: Path,
    duration: float = 10.0,
    spawn_args: Optional[List[str]] = None
) -> bool:
    """Run dynamic trace capturing all callsites in vulnerability path."""
    print(f"\n[2/4] Starting dynamic trace (duration: {duration}s)...")

    # Build callsite arguments
    callsite_args = []
    for addr in VULNERABILITY_PATH_ADDRESSES.keys():
        callsite_args.extend(["--callsite", hex(addr)])

    # Build function arguments
    fn_args = []
    for fn in FUNCTIONS_TO_TRACE:
        fn_args.extend(["--fn", fn])

    cmd = [
        "python", "-m", "dynint.cli", "trace",
        "--spawn", str(binary_path),
        "--map", str(map_path),
        "--output", str(output_path),
        "--duration", str(duration),
    ]
    cmd.extend(callsite_args)
    cmd.extend(fn_args)

    if spawn_args:
        cmd.append("--args")
        cmd.extend(spawn_args)

    print(f"  Tracing {len(VULNERABILITY_PATH_ADDRESSES)} callsites")
    print(f"  Tracing {len(FUNCTIONS_TO_TRACE)} functions")
    print(f"  Command: {' '.join(cmd[:10])}... (truncated)")

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"  ‚ùå Trace failed!")
        print(f"  stderr: {result.stderr}")
        return False

    print(f"  ‚úÖ Trace completed: {output_path}")
    return True


def analyze_trace(trace_path: Path, output_path: Optional[Path] = None) -> None:
    """Analyze the trace and output the execution path."""
    print(f"\n[3/4] Analyzing trace...")

    if not trace_path.exists():
        print(f"  ‚ùå Trace file not found: {trace_path}")
        return

    events: List[Dict] = []
    with open(trace_path) as f:
        for line in f:
            if line.strip():
                events.append(json.loads(line))

    print(f"  Total events captured: {len(events)}")

    # Separate by kind
    function_events = [e for e in events if e.get("kind") == "function"]
    callsite_events = [e for e in events if e.get("kind") == "callsite"]

    print(f"  Function calls: {len(function_events)}")
    print(f"  Callsite hits: {len(callsite_events)}")

    # Group callsites by group
    grouped_callsites: Dict[str, List[Dict]] = {}
    for event in callsite_events:
        static_addr_str = event.get("static", "")
        if static_addr_str:
            try:
                static_addr = int(static_addr_str, 16)
                if static_addr in VULNERABILITY_PATH_ADDRESSES:
                    info = VULNERABILITY_PATH_ADDRESSES[static_addr]
                    group = info["group"]
                    if group not in grouped_callsites:
                        grouped_callsites[group] = []
                    grouped_callsites[group].append({
                        "addr": hex(static_addr),
                        "desc": info["desc"],
                        "event": event
                    })
            except ValueError:
                pass

    # Build the execution path report
    report_lines = []
    report_lines.append("="*80)
    report_lines.append("VULNERABILITY PATH TRACE: recvfrom ‚Üí CWE-20")
    report_lines.append("="*80)
    report_lines.append("")

    # Sort groups by execution order
    group_order = [
        "RECVFROM_SETUP",
        "RECVFROM_RESULT",
        "PACKET_LOGGING",
        "PARSECCSDS_SETUP",
        "PUS_HEADER_CALC",
        "PUS_VERSION",
        "SERVICE_TYPE_READ",
        "PROCESSPUS_SETUP",
        "PROCESSPUS_PARAMS",
        "CWE20_VULNERABILITY"
    ]

    instruction_count = 0
    for group_name in group_order:
        if group_name in grouped_callsites:
            report_lines.append(f"üìç {group_name}")
            report_lines.append("-" * 80)

            for item in grouped_callsites[group_name]:
                instruction_count += 1
                report_lines.append(f"  {instruction_count:2d}. {item['addr']}: {item['desc']}")

                event = item['event']
                if 'runtime' in event:
                    report_lines.append(f"      Runtime addr: {event['runtime']}")
                if 'tid' in event:
                    report_lines.append(f"      Thread ID: {event['tid']}")

            report_lines.append("")

    # Add function call summary
    report_lines.append("="*80)
    report_lines.append("FUNCTION CALLS SUMMARY")
    report_lines.append("="*80)
    report_lines.append("")

    for func_event in function_events:
        func_name = func_event.get("function", "unknown")
        args = func_event.get("args", [])
        ret = func_event.get("ret", "unknown")
        duration = func_event.get("duration", 0)

        report_lines.append(f"Function: {func_name}")
        report_lines.append(f"  Arguments: {args[:4]}")  # First 4 args
        report_lines.append(f"  Return: {ret}")
        report_lines.append(f"  Duration: {duration:.6f}s")

        if "callsite" in func_event:
            cs = func_event["callsite"]
            report_lines.append(f"  Called from: {cs.get('callsite', 'unknown')}")
            if cs.get("function"):
                report_lines.append(f"  Calling function: {cs['function']}")
        report_lines.append("")

    # Statistics
    report_lines.append("="*80)
    report_lines.append("STATISTICS")
    report_lines.append("="*80)
    report_lines.append(f"Total instructions traced: {instruction_count}")
    report_lines.append(f"Total callsite groups executed: {len(grouped_callsites)}")
    report_lines.append(f"Total function calls: {len(function_events)}")
    report_lines.append("")

    # Critical path check
    critical_groups = ["SERVICE_TYPE_READ", "CWE20_VULNERABILITY"]
    critical_hit = all(g in grouped_callsites for g in critical_groups)

    if critical_hit:
        report_lines.append("üö® CRITICAL: Vulnerability path EXECUTED!")
        report_lines.append("    The service_type byte was read from network packet")
        report_lines.append("    and reached the insufficient validation at 0x2e40")
    else:
        report_lines.append("‚ö†Ô∏è  WARNING: Vulnerability path NOT fully executed")
        report_lines.append(f"   Missing groups: {[g for g in critical_groups if g not in grouped_callsites]}")

    report_lines.append("="*80)

    # Output report
    report_text = "\n".join(report_lines)
    print("\n" + report_text)

    if output_path:
        with open(output_path, "w") as f:
            f.write(report_text)
        print(f"\n  ‚úÖ Report saved to: {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Trace execution path from recvfrom to CWE-20 vulnerability",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage
  python trace_vulnerability_path.py --binary ./spacecraft_server_linux_x86

  # With custom duration and output
  python trace_vulnerability_path.py --binary ./spacecraft_server_linux_x86 \\
      --duration 20 --output results/trace.jsonl

  # Docker usage
  docker compose run --rm dynint-frida python trace_vulnerability_path.py \\
      --binary ./spacecraft_server_linux_x86
        """
    )

    parser.add_argument(
        "--binary",
        type=Path,
        default=Path("./spacecraft_server_linux_x86"),
        help="Path to the spacecraft server binary"
    )
    parser.add_argument(
        "--map-output",
        type=Path,
        default=Path("output/vulnerability_map.json"),
        help="Output path for static map"
    )
    parser.add_argument(
        "--trace-output",
        type=Path,
        default=Path("output/vulnerability_trace.jsonl"),
        help="Output path for dynamic trace"
    )
    parser.add_argument(
        "--report-output",
        type=Path,
        default=Path("output/vulnerability_report.txt"),
        help="Output path for analysis report"
    )
    parser.add_argument(
        "--duration",
        type=float,
        default=10.0,
        help="Duration to run trace (seconds)"
    )
    parser.add_argument(
        "--skip-map",
        action="store_true",
        help="Skip map generation (use existing map)"
    )
    parser.add_argument(
        "--spawn-args",
        nargs="*",
        help="Additional arguments to pass to the spawned binary"
    )

    args = parser.parse_args()

    # Ensure output directory exists
    args.map_output.parent.mkdir(parents=True, exist_ok=True)
    args.trace_output.parent.mkdir(parents=True, exist_ok=True)
    args.report_output.parent.mkdir(parents=True, exist_ok=True)

    print("="*80)
    print("SPACECRAFT SERVER VULNERABILITY PATH TRACER")
    print("="*80)
    print(f"Binary: {args.binary}")
    print(f"Map output: {args.map_output}")
    print(f"Trace output: {args.trace_output}")
    print(f"Report output: {args.report_output}")
    print("="*80)
    print()

    # Step 1: Generate map (unless skipped)
    if not args.skip_map:
        if not run_map_generation(args.binary, args.map_output):
            print("\n‚ùå Failed at map generation step")
            return 1
    else:
        print("[1/4] Skipping map generation (using existing map)")

    # Step 2: Run trace
    if not run_trace(
        args.binary,
        args.map_output,
        args.trace_output,
        args.duration,
        args.spawn_args
    ):
        print("\n‚ùå Failed at trace step")
        return 1

    # Give trace time to flush
    time.sleep(1)

    # Step 3: Analyze trace
    analyze_trace(args.trace_output, args.report_output)

    print("\n[4/4] ‚úÖ Complete!")
    print(f"\nResults:")
    print(f"  - Static map: {args.map_output}")
    print(f"  - Trace data: {args.trace_output}")
    print(f"  - Analysis report: {args.report_output}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
